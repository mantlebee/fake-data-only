import { Any, List, KeyOf } from "@mantlebee/ts-core";
import { generateRandomBoolean } from "@mantlebee/ts-random";

import { ColumnOptions, CountsMap, Dataset, Row, TableKey } from "./types";
import { ColumnAbstract, ColumnRelationAbstract, Table } from "./models";

/**
 * Creates a typed key for the {@link Table} model.
 * The `description` property of the key is the name of the table.
 */
export const createTableKey = <TRow>(tableName: string) =>
  Symbol(tableName) as TableKey<TRow>;

/**
 * Generates a database dataset using the given tables and relations.
 * It is separated into two steps:
 *  1. it generates the table rows.
 *  2. process the relation columnss to update the rows values.
 * Columns of type relation of the tables are processed during the second step if and only if a relation referring that column is present. If not, the default value is not updated.
 * @param tables List of tables forming part of the database.
 * @param countsMap Dictionary with the tables counts, used to generate a specific amount of rows for each table. It is a dictionary where the keys are the tables keys and the values the row counts to generate.
 * @returns the database dataset, it is a dictionary, where the keys are the tables names and keys, and the values are the generated rows.
 */
export function getDatabaseDataset(
  tables: List<Table<Any>>,
  countsMap: CountsMap
): Dataset {
  const dataset = tables.reduce((result, current) => {
    const key = current.getKey();
    const count = countsMap[key] || 0;
    current.seed(count);
    const rows = current.getRows();
    result[key] = rows;
    result[key.description] = rows;
    return result;
  }, {} as Dataset);
  tables.forEach((table) => {
    table
      .getColumns()
      .filter((a) => a instanceof ColumnRelationAbstract)
      .forEach((column) => {
        const sourceRows = dataset[table.getKey()];
        const targetRows = dataset[column.targetTableKey];
        if (sourceRows && targetRows)
          column.setValues(sourceRows, targetRows, dataset);
      });
  });
  return dataset;
}

export const getDatasetRows = <TRow extends Row>(
  dataset: Dataset,
  tableKey: TableKey<TRow>
) => dataset[tableKey] as List<TRow>;

/**
 * Generates rows for a table where the keys are the columns names.
 * If the column if nullable, the {@link shouldBeNull} defines if the `null` value is used or a random one must be generated by the column {@link IColumn["getValue"]} method.
 * @param columns List of columns used to update the rows values.
 * @param rowsCount Number of rows to generated.
 * @returns Rows generated where the keys are the columns names.
 */
export function getTableRows<TRow extends Row>(
  columns: List<ColumnAbstract<TRow, Any>>,
  rowsCount: number
): List<TRow> {
  const items: List<TRow> = [];
  for (let i = 0; i < rowsCount; i++) {
    const row: TRow = {} as TRow;
    columns.forEach((a) => {
      const options = a.getOptions(row);
      if (shouldBeNull(a, options)) row[a.name] = null as TRow[KeyOf<TRow>];
      else row[a.name] = a.getValue({ ...row });
    });
    items.push(row);
  }
  return items;
}

/**
 * Returns a random boolean value indicating if to generate a value for the current column or to set the `null` value.
 * If the column is a relation column and it is nullable, the method returns `true`.
 * @param column Column processing during the table rows generation.
 * @returns A boolean value indicating if to generate a value for the current column or to set the `null` value.
 */
function shouldBeNull<TRow extends Row>(
  column: ColumnAbstract<TRow>,
  options: ColumnOptions
): boolean {
  const { nullable } = options;
  return Boolean(
    (column instanceof ColumnRelationAbstract && nullable) ||
      (nullable && generateRandomBoolean())
  );
}
